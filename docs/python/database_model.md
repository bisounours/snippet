# Python script to generate database model

## 1. Description
This script is based on 3 files : 
- List of table / Columns of the database schema
- List of unique constraint
- List of foreign keys

For Oracle, these files can be generated by the SQL script described [here](../oracle/oracle_model_snippet.md). 

The script generates 2 output files :
- File with database model in DOT format
- File with database model in Mermaid format

## 2. Configuration

The script contains 6 variables which can be configured : 
```python
# The CSV file must have the following fields : TABLE_NAME;COLUMN_NAME;TYPE;CHAR_LENGH;NUMBER_LENGTH;CONSTRAINT_TYPE
allColumnFile = open('allColumnsKO3.csv','r')
# The CSV file must have the following fields : TABLE_NAME;COLUMN_NAME;CONSTRAINT_NAME;FOREIGN_TABLE_NAME;FOREIGN_COLUMN_NAME
allForeignKeysFile = open('allForeignKeysKO3.csv','r')
# The CSV file must have the following fields : TABLE_NAME;COLUMN_NAME;CONSTRAINT_NAME
allUniqueConstraintFile = open('allUniqueConstraintKO3.csv','r')
# Table pattern to filter 
pattern = "KO3Q[T|V]P[0-9]+|KO3QTDRE|KO3QTDRI"

# The result file use the mermaid format for entioty relationship diagram
resultFileDot = open('modelDiagramDot.txt','w')
resultFileMermaid = open('modelDiagramMermaid.txt','w')
```

- allColumnFile : path to the file which contains all the tables/columns (format of the file specified in comment)
- allForeignKeysFile : path to the file which contains all the foreign keys (format of the file specified in comment)
- allUniqueConstraintFile : path to the file which contains all the unique constraints (format of the file specified in comment)
- pattern : pattern to filter on the table name
- resultFileDot and resultFileMermaid : output files

## 3. Full script

```python
# coding=UTF-8
import sys
import re

class Column :
	def __init__(self, name, type, charLength, numberLength, constraint):
		self.name = name
		self.type = type
		self.charLength = charLength
		self.numberLength = numberLength
		self.constraint = constraint
	
	def __eq__(self, other): 
		if not isinstance(other, Column) :
			# don't attempt to compare against unrelated types
			return NotImplemented;
		return self.name == other.name and self.type == other.type and self.charLength == other.charLength and self.numberLength == other.numberLength and self.constraint == other.constraint

	def __hash__(self):
		# necessary for instances to behave sanely in dicts and sets.
		return hash((self.name, self.type, self.charLength, self.numberLength, self.constraint))
	
# The CSV file must have the following fields : TABLE_NAME;COLUMN_NAME;TYPE;CHAR_LENGH;NUMBER_LENGTH;CONSTRAINT_TYPE
allColumnFile = open('allColumnsKO3.csv','r')
# The CSV file must have the following fields : TABLE_NAME;COLUMN_NAME;CONSTRAINT_NAME;FOREIGN_TABLE_NAME;FOREIGN_COLUMN_NAME
allForeignKeysFile = open('allForeignKeysKO3.csv','r')
# The CSV file must have the following fields : TABLE_NAME;COLUMN_NAME;CONSTRAINT_NAME
allUniqueConstraintFile = open('allUniqueConstraintKO3.csv','r')
# Table pattern to filter 
pattern = "KO3Q[T|V]P[0-9]+|KO3QTDRE|KO3QTDRI"

# The result file use the mermaid format for entioty relationship diagram
resultFileDot = open('modelDiagramDot.txt','w')
resultFileMermaid = open('modelDiagramMermaid.txt','w')

# Group by table
tableMap = {}
for columnLine in allColumnFile :
	lineList = columnLine.rstrip('\n').split(';');
	tableName = lineList[0];
	if re.search(pattern,tableName) is not None :
		columnName = lineList[1];
		col = Column(lineList[1],lineList[2],lineList[3],lineList[4],lineList[5]);
		if tableName in tableMap :	
			# print(tableName+" found in table map");
			if columnName in tableMap[tableName] :
				# print(columnName+" found in column map");
				tableMap[tableName][columnName].append(col);
			else :
				# print(columnName+" not found in column map");
				tableMap[tableName][columnName] = [col];
		else :
			# print(columnName+" not found in column map");
			tableMap[tableName] = {columnName : [col]};

# Group unique constraint
uniqueConstraintMap = {}
for uniqueConstraint in allUniqueConstraintFile :
	lineList = uniqueConstraint.rstrip('\n').split(';');
	tableName = lineList[0];
	if re.search(pattern,tableName) is not None :
		columnName = lineList[1];
		constraintName = lineList[2];
		if tableName in uniqueConstraintMap :	
			if constraintName in uniqueConstraintMap[tableName] :
				uniqueConstraintMap[tableName][constraintName].append(columnName);
			else :
				uniqueConstraintMap[tableName][constraintName] = [columnName];
		else :
			uniqueConstraintMap[tableName] = {constraintName : [columnName]};
		
# Creation of DOT graph
resultFileDot.write('digraph g {\n');
resultFileMermaid.write('erDiagram\n');

# Creation of tables description
for table in tableMap :
	resultFileDot.write('\t"'+table+'" [\n\t\tlabel = <<table CELLSPACING=\'0\' CELLPADDING=\'2\'><tr><td bgcolor=\'#5ac3ed\' colspan=\'4\'> '+table+'</td></tr>');
	resultFileMermaid.write('\t'+table+' {\n');
	for columnName in tableMap[table] :
		isNotNull = False;
		isPrimary = False;
		columnType = '';
		charLength = '';
		numberLength = '';
		for column in tableMap[table][columnName] : 
			columnType = column.type;
			charLength = column.charLength;
			numberLength = column.numberLength;
			if column.constraint == 'C' :
				isNotNull = True;
			elif column.constraint == 'P' :
				isPrimary = True;
				
		if columnType == 'VARCHAR2' :
			resultFileDot.write('<tr><td>'+columnName+'</td><td>'+columnType+'('+charLength+')</td>');
			resultFileMermaid.write('\t\t'+columnType+'('+charLength+') '+columnName+' ');
		elif columnType == 'NUMBER' :
			resultFileDot.write('<tr><td>'+columnName+'</td><td>'+columnType+'('+numberLength+')</td>');
			resultFileMermaid.write('\t\t'+columnType+'('+numberLength+') '+columnName+' ');
		else :
			resultFileDot.write('<tr><td>'+columnName+'</td><td>'+columnType+'</td>');
			resultFileMermaid.write('\t\t'+columnType+' '+columnName+' ');
		
		if isPrimary :
			resultFileDot.write('<td>Primary key</td></tr>');
			resultFileMermaid.write('PK ');
		else :
			resultFileDot.write('<td></td>');
		
		if isNotNull :
			resultFileDot.write('<td>NOT NULL</td>');
			resultFileMermaid.write('"NOT NULL"\n');
		else :
			resultFileDot.write('<td></td></tr>');
			resultFileMermaid.write('\n');
		
	# Add unique constraint associated to the table
	if table in uniqueConstraintMap :
		resultFileDot.write('<tr><td bgcolor=\'#a8daed\' colspan=\'4\' > UNIQUE CONSTRAINTS </td></tr>');
		for constraintName in uniqueConstraintMap[table] :
			resultFileDot.write('<tr><td colspan=\'1\'>'+constraintName+'</td><td colspan=\'3\'>'+', '.join(uniqueConstraintMap[table][constraintName])+'</td></tr>')
		
	resultFileDot.write(' </table>>\n');
	resultFileDot.write('\t\tshape="record"\n');
	resultFileDot.write('\t];\n\n');
	resultFileMermaid.write('\t}\n\n')

# Creation of foreign description
for foreignKeyLine in allForeignKeysFile :
	if re.search(pattern,foreignKeyLine) is not None :
		foreignKey = foreignKeyLine.rstrip('\n').split(';');
		resultFileDot.write('\t"'+foreignKey[0]+'" -> "'+foreignKey[3]+'"[label="'+foreignKey[2]+' ('+foreignKey[1]+" = "+foreignKey[4]+')";color="purple";fontcolor="purple"]\n');
		resultFileMermaid.write('\t'+foreignKey[0]+' ||--o{ '+foreignKey[3]+' : "'+foreignKey[2]+' ('+foreignKey[1]+" = "+foreignKey[4]+')"\n');
	
	
resultFileDot.write('}');
```
